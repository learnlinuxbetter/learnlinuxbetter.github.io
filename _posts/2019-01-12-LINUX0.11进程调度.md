---
title: LINUX0.11进程调度
date: 2019-01-12 00:00:00
categories: linux内核分析
tags:


---

void schedule(void)是调度函数的原型，在kernel/sched.c文件中定义。

## 一、进程调度的时机

1、进程调度发生在时钟中断到来时 2、内核由于等待硬件资源而主动放弃cpu时。由于schedule()本身就是时钟中断例程的一部分，所以每次时钟中断到来时都会执行schedule()。当内核要访问的硬件资源还未准备好，此时进程进入睡眠状态执行schedule()切换到其他就绪态任务主动交出cpu使用权。

## 二、SCHEDULE()

schedule()函数是整个进程调度的核心，他首先要完成对所有进程的预处理，发送定时器信号给已达到定时时间的进程，唤醒有信号待处理的进程。简而言之就是将所有符合运行条件的进程都置为就绪态（TASK_RUNNING）。

![img](https://qiutianshu.files.wordpress.com/2019/01/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190112204223.png?w=716&h=247)
<p style="text-align: center">kernel/sched.c</p>

接下来就是调度算法的核心。从后往前遍历所有进程，挑选出运行时间最短的进程（进程的产生有先后，而且一旦被阻塞将导致大部分时间处于睡眠状态），这是一种公平调度算法让所有进程都尽可能平等地占用cpu不至于让某些进程“饿死”。

![img](https://qiutianshu.files.wordpress.com/2019/01/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190112204813.png?w=711&h=293)
<p style="text-align: center">kernel/sched.c</p>

如果所有**就绪态进程**的时间片都已经使用完就给**所有**进程加上counter/2+priority个时间片。注意此时可能还存在**阻塞状态**的进程，虽然他们的时间片没有使用完，但是**不参加调度**。对于就绪态进程，他们又获得priority个时间片，对于阻塞态进程，即使一直阻塞下去，一直获得时间片，时间片累加和也会有极限值而不会一直无限增长，这是一个设计很巧妙的地方。

在重新获得时间片之后再次进行比较选择出一个符合条件的进程。

## 三、进程切换

进程切换发生在switch_to，它是一个汇编宏。我发现Linux0.11中定义有很多的宏，使用宏替换函数调用将大大减少函数调用的开销，同时也减少了堆栈的使用，保持了堆栈的清洁。

![img](https://qiutianshu.files.wordpress.com/2019/01/%E6%B7%B1%E5%BA%A6%E6%88%AA%E5%9B%BE_%E9%80%89%E6%8B%A9%E5%8C%BA%E5%9F%9F_20190112234112.png?w=681&h=195)
<p style="text-align: center">include/linux/sched.h</p>

这里定义了一个64位的临时变量作为临时的任务门，任务门的32~48位填充TSS选择子，其余位无效。数据交换指令将current变量和ecx寄存器交换，使current指向被选中的进程。ljmp长跳转指令如果跟的操作数是一个指向任务门的地址则此时发生任务切换，cpu将会自动把原来进程的现场保存到旧的TSS中，并且加载新的TSS。这里需要注意的是由于保存的现场是ljmp的下一条指令，所以当进程被切换回来的时候都是从cmpl指令开始运行，如果是因为时钟中断而导致的进程切换的话那么切换回来的时候还是在内核态，需要ret_from_sys_call来完成信号的处理并恢复到正常的用户空间。